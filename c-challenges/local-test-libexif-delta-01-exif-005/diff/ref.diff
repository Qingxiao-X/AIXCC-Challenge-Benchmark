diff --git a/.aixcc/README.md b/.aixcc/README.md
new file mode 100644
index 0000000..7a6fc1b
--- /dev/null
+++ b/.aixcc/README.md
@@ -0,0 +1,13 @@
+# libexif - mnotably buggy
+This challenge is a delta scan challenge. It contains three vulnerabilities:
+- exif-003
+- exif-004
+- exif-005
+
+Back in 2021, the author of libexif added a brand new parser to handle Apple-specific MessageNote data. This did not sit well with ossfuzz, which handed out some 10 crash reports over the next couple of days.
+
+This suite of vulnerabilities partially reverts the bug fixes doled out by the author as ossfuzz kept filing bugs. I did some git-fu to delete a handful of the fix commits, then squashed them down into the original adding of the parser, so there's still one inducing commit but lots of bugs have already been prevented. This helped keep my workload down as well as the number of vulns (we don't need exif-015). I do suspect my deletions are imperfect and there will be a couple other ways to cause a crash due to various fixes depending on other fixes etc. It definitely worked in the other way, as I wanted one or two more but other fixes blocked some of them from being reached.
+
+# Challenge Rounds
+This challenge to be staged for the following set of rounds:
+- Exhibition Round 3
\ No newline at end of file
diff --git a/.aixcc/challenge.yaml b/.aixcc/challenge.yaml
new file mode 100644
index 0000000..1939db0
--- /dev/null
+++ b/.aixcc/challenge.yaml
@@ -0,0 +1,30 @@
+metadata_spec_version: v1
+
+name: 'mnotably buggy'
+
+# fuzz_tooling project info that pairs to this challenge
+fuzz_tooling_project_name: 'libexif'
+fuzz_tooling_url: https://github.com/aixcc-finals/oss-fuzz-aixcc.git
+fuzz_tooling_ref: challenge-state/ex-delta-01
+
+challenge_type: delta     # full | delta
+
+base_ref: ffcdfbeb5539c25b1630ba59abf8a22587657adc
+delta_ref: challenges/ex-delta-01
+
+# A list of the vulnerabilities included in this challenge
+# This should always match the dir names in .aixcc/vulns/*
+vulnerabilities:
+    - exif-003
+    - exif-004
+    - exif-005
+
+sarif:
+    broadcast: false
+    target: null
+    correct: null
+
+# harness fuzz targets available for this challenge
+harnesses:
+    - 'exif_loader_fuzzer'
+    - 'exif_from_data_fuzzer'
diff --git a/.aixcc/test.sh b/.aixcc/test.sh
new file mode 100755
index 0000000..92a5942
--- /dev/null
+++ b/.aixcc/test.sh
@@ -0,0 +1,5 @@
+#!/bin/bash
+
+autoreconf -fi
+./configure
+make all check
diff --git a/.aixcc/vulns/exif-003/README.md b/.aixcc/vulns/exif-003/README.md
new file mode 100644
index 0000000..781aef8
--- /dev/null
+++ b/.aixcc/vulns/exif-003/README.md
@@ -0,0 +1,9 @@
+# exif-003, Apple MNote parsing bug 1
+
+Back in 2021, the author of libexif added a brand new parser to handle Apple-specific MessageNote data. This did not sit well with ossfuzz, which handed out some 10 crash reports over the next couple of days.
+
+This suite of vulnerabilities partially reverts the bug fixes doled out by the author as ossfuzz kept filing bugs. I did some git-fu to delete a handful of the fix commits, then squashed them down into the original adding of the parser, so there's still one inducing commit but lots of bugs have already been prevented. This helped keep my workload down as well as the number of vulns (we don't need exif-015). I do suspect my deletions are imperfect and there will be a couple other ways to cause a crash due to various fixes depending on other fixes etc. It definitely worked in the other way, as I wanted one or two more but other fixes blocked some of them from being reached.
+
+I matched the ossfuzz crash reports to the fixing commits by observing when ossfuzz verified that a crash was fixed, matching that to the list of commits made that day, and then bisecting them by hand. 
+
+This is reverted commit 790fb01: exif-003
diff --git a/.aixcc/vulns/exif-003/blobs/data.bin b/.aixcc/vulns/exif-003/blobs/data.bin
new file mode 100644
index 0000000..ca87330
Binary files /dev/null and b/.aixcc/vulns/exif-003/blobs/data.bin differ
diff --git a/.aixcc/vulns/exif-003/patches/good_patch.diff b/.aixcc/vulns/exif-003/patches/good_patch.diff
new file mode 100644
index 0000000..1d340c6
--- /dev/null
+++ b/.aixcc/vulns/exif-003/patches/good_patch.diff
@@ -0,0 +1,23 @@
+diff --git a/libexif/apple/exif-mnote-data-apple.c b/libexif/apple/exif-mnote-data-apple.c
+index 83a9cb1..413ede1 100644
+--- a/libexif/apple/exif-mnote-data-apple.c
++++ b/libexif/apple/exif-mnote-data-apple.c
+@@ -235,15 +235,9 @@ exif_mnote_data_apple_get_value(ExifMnoteData *md, unsigned int i, char *val, un
+ 
+ int
+ exif_mnote_data_apple_identify(const ExifData *ed, const ExifEntry *e) {
+-    int variant;
+-
+-    if (!strcmp((const char *) e->data, "Apple iOS")) {
+-        variant = 1;
+-    } else {
+-        variant = 0;
+-    }
+-
+-    return variant;
++    if (e->size < strlen("Apple iOS")+1)
++        return 0;
++    return !memcmp((const char*) e->data, "Apple iOS", strlen("Apple iOS"));
+ }
+ 
+ ExifMnoteData *
diff --git a/.aixcc/vulns/exif-003/vuln.yaml b/.aixcc/vulns/exif-003/vuln.yaml
new file mode 100644
index 0000000..da7aed4
--- /dev/null
+++ b/.aixcc/vulns/exif-003/vuln.yaml
@@ -0,0 +1,29 @@
+metadata_spec_version: v1
+
+name: exif-003, apple mnote bug 1
+
+author: factsphere
+
+details:
+
+  cwes:
+    - CWE-122
+
+  description: >
+    An out of bounds read in the indentification
+    code leads to a heap-based buffer overflow.
+
+  locations:
+    - path_from_root: "libexif/apple/exif-mnote-data-apple.c"
+      startLine: 236
+      startColumn: 1
+      endLine: 247
+      endColumn: 1
+
+pov:
+  harness: 'exif_loader_fuzzer'
+  blob: 'data.bin'
+
+patch:
+  good: 'good_patch.diff'
+  bad: ~
diff --git a/.aixcc/vulns/exif-004/README.md b/.aixcc/vulns/exif-004/README.md
new file mode 100644
index 0000000..d020b72
--- /dev/null
+++ b/.aixcc/vulns/exif-004/README.md
@@ -0,0 +1,9 @@
+# exif-004, Apple MNote parsing bug 2
+
+Back in 2021, the author of libexif added a brand new parser to handle Apple-specific MessageNote data. This did not sit well with ossfuzz, which handed out some 10 crash reports over the next couple of days.
+
+This suite of vulnerabilities partially reverts the bug fixes doled out by the author as ossfuzz kept filing bugs. I did some git-fu to delete a handful of the fix commits, then squashed them down into the original adding of the parser, so there's still one inducing commit but lots of bugs have already been prevented. This helped keep my workload down as well as the number of vulns (we don't need exif-015). I do suspect my deletions are imperfect and there will be a couple other ways to cause a crash due to various fixes depending on other fixes etc. It definitely worked in the other way, as I wanted one or two more but other fixes blocked some of them from being reached.
+
+I matched the ossfuzz crash reports to the fixing commits by observing when ossfuzz verified that a crash was fixed, matching that to the list of commits made that day, and then bisecting them by hand.
+
+This is reverted commit 2279932: exif-004
diff --git a/.aixcc/vulns/exif-004/blobs/data.bin b/.aixcc/vulns/exif-004/blobs/data.bin
new file mode 100644
index 0000000..3cc1ed5
Binary files /dev/null and b/.aixcc/vulns/exif-004/blobs/data.bin differ
diff --git a/.aixcc/vulns/exif-004/patches/good_patch.diff b/.aixcc/vulns/exif-004/patches/good_patch.diff
new file mode 100644
index 0000000..1caf9fa
--- /dev/null
+++ b/.aixcc/vulns/exif-004/patches/good_patch.diff
@@ -0,0 +1,16 @@
+diff --git a/libexif/apple/exif-mnote-data-apple.c b/libexif/apple/exif-mnote-data-apple.c
+index 83a9cb1..b3bc68b 100644
+--- a/libexif/apple/exif-mnote-data-apple.c
++++ b/libexif/apple/exif-mnote-data-apple.c
+@@ -128,6 +128,11 @@ exif_mnote_data_apple_load(ExifMnoteData *md, const unsigned char *buf, unsigned
+             EXIF_LOG_NO_MEMORY(md->log, "ExifMnoteApple", dsize);
+             continue;
+         }
++        if (dofs + dsize > buf_size) {
++            exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
++                "ExifMnoteApplet", "Tag size overflow detected (%u vs size %u)", dofs + dsize, buf_size);
++            continue;
++        }
+         memcpy(d->entries[i].data, buf + dofs, dsize);
+         d->entries[i].size = dsize;
+     }
diff --git a/.aixcc/vulns/exif-004/vuln.yaml b/.aixcc/vulns/exif-004/vuln.yaml
new file mode 100644
index 0000000..59c1780
--- /dev/null
+++ b/.aixcc/vulns/exif-004/vuln.yaml
@@ -0,0 +1,32 @@
+metadata_spec_version: v1
+
+# Developer-given name of the vulnerability
+name: exif-004, apple mnote bug 2
+
+# Author of the vuln (anonymous if desired)
+author: factsphere
+
+# Collective information used to generate SARIF reports
+details:
+
+  # one or more CWEs that correspond to this vuln
+  cwes:
+    - CWE-122
+
+  description: >
+    This is a buffer over-read from a memcpy.
+
+  locations:
+    - path_from_root: "libexif/apple/exif-mnote-data-apple.c"
+      startLine: 131
+      startColumn: 1
+      endLine: 132
+      endColumn: 1
+
+pov:
+  harness: 'exif_loader_fuzzer'
+  blob: 'data.bin'
+
+patch:
+  good: 'good_patch.diff'
+  bad: ~
diff --git a/.aixcc/vulns/exif-005/README.md b/.aixcc/vulns/exif-005/README.md
new file mode 100644
index 0000000..d621a9f
--- /dev/null
+++ b/.aixcc/vulns/exif-005/README.md
@@ -0,0 +1,9 @@
+# exif-005: Apple MNote parsing bug 3
+
+Back in 2021, the author of libexif added a brand new parser to handle Apple-specific MessageNote data. This did not sit well with ossfuzz, which handed out some 10 crash reports over the next couple of days.
+
+This suite of vulnerabilities partially reverts the bug fixes doled out by the author as ossfuzz kept filing bugs. I did some git-fu to delete a handful of the fix commits, then squashed them down into the original adding of the parser, so there's still one inducing commit but lots of bugs have already been prevented. This helped keep my workload down as well as the number of vulns (we don't need exif-015). I do suspect my deletions are imperfect and there will be a couple other ways to cause a crash due to various fixes depending on other fixes etc. It definitely worked in the other way, as I wanted one or two more but other fixes blocked some of them from being reached.
+
+I matched the ossfuzz crash reports to the fixing commits by observing when ossfuzz verified that a crash was fixed, matching that to the list of commits made that day, and then bisecting them by hand.
+
+This is reverted commit eb452f5: exif-005
diff --git a/.aixcc/vulns/exif-005/blobs/data.bin b/.aixcc/vulns/exif-005/blobs/data.bin
new file mode 100644
index 0000000..55996c3
Binary files /dev/null and b/.aixcc/vulns/exif-005/blobs/data.bin differ
diff --git a/.aixcc/vulns/exif-005/patches/good_patch.diff b/.aixcc/vulns/exif-005/patches/good_patch.diff
new file mode 100644
index 0000000..0807547
--- /dev/null
+++ b/.aixcc/vulns/exif-005/patches/good_patch.diff
@@ -0,0 +1,43 @@
+diff --git a/libexif/apple/exif-mnote-data-apple.c b/libexif/apple/exif-mnote-data-apple.c
+index 83a9cb1..4d7867d 100644
+--- a/libexif/apple/exif-mnote-data-apple.c
++++ b/libexif/apple/exif-mnote-data-apple.c
+@@ -85,12 +85,13 @@ exif_mnote_data_apple_load(ExifMnoteData *md, const unsigned char *buf, unsigned
+     tcount = (unsigned int) exif_get_short(buf + ofs + 14, d->order);
+ 
+     /* Sanity check the offset */
+-    if (buf_size < 6 + 16 + tcount * 6 + 4) {
++    if (buf_size < d->offset + 6 + 16 + tcount * 12 + 4) {
+         exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                  "ExifMnoteDataApple", "Short MakerNote");
+         /*printf("%s(%d)\n", __FUNCTION__, __LINE__);*/
+         return;
+     }
++    memset(d->entries, 0, sizeof(MnoteAppleEntry) * tcount);
+ 
+     /* printf("%s(%d): total %d tags\n", __FUNCTION__, __LINE__, tcount); */
+ 
+@@ -107,6 +108,11 @@ exif_mnote_data_apple_load(ExifMnoteData *md, const unsigned char *buf, unsigned
+     }
+ 
+     for (i = 0; i < tcount; i++) {
++	if (ofs + 12 > buf_size) {
++		exif_log (md->log, EXIF_LOG_CODE_CORRUPT_DATA,
++                                  "ExifMnoteApplet", "Tag size overflow detected (%u vs size %u)", ofs + 12, buf_size);
++		break;
++	}
+         d->entries[i].tag = exif_get_short(buf + ofs, d->order);
+         d->entries[i].format = exif_get_short(buf + ofs + 2, d->order);
+         d->entries[i].components = exif_get_long(buf + ofs + 4, d->order);
+@@ -159,9 +165,8 @@ exif_mnote_data_apple_set_byte_order(ExifMnoteData *md , ExifByteOrder o) {
+     }
+ 
+     for (i = 0; i < d->count; i++) {
+-        if (d->entries[i].size != (exif_format_get_size(d->entries[i].format) * d->entries[i].components)) {
+-            continue;
+-        }
++	if (d->entries[i].components && (d->entries[i].size/d->entries[i].components < exif_format_get_size (d->entries[i].format)))
++		continue;
+         exif_array_set_byte_order(d->entries[i].format, d->entries[i].data,
+                                   d->entries[i].components, d->entries[i].order, o);
+         d->entries[i].order = o;
diff --git a/.aixcc/vulns/exif-005/vuln.yaml b/.aixcc/vulns/exif-005/vuln.yaml
new file mode 100644
index 0000000..ec1fe62
--- /dev/null
+++ b/.aixcc/vulns/exif-005/vuln.yaml
@@ -0,0 +1,48 @@
+metadata_spec_version: v1
+
+# Developer-given name of the vulnerability
+name: exif-005, apple mnote bug 3
+
+# Author of the vuln (anonymous if desired)
+author: factsphere
+
+# Collective information used to generate SARIF reports
+details:
+
+  # one or more CWEs that correspond to this vuln
+  cwes:
+    - CWE-122
+
+  # short, descriptive message detailing the vuln
+  # * written as a report description *
+  description: >
+    Heap buffer overflow caused by an insufficient
+    bounds check.
+
+  # list notable locations of the vuln
+  # this list can be 1-N locations
+  # this is not to be comprehensive of all changes
+  locations:
+    - path_from_root: "libexif/apple/exif-mnote-data-apple.c"
+      startLine: 88
+      startColumn: 1
+      endLine: 94
+      endColumn: 1
+    - path_from_root: "libexif/apple/exif-mnote-data-apple.c"
+      startLine: 110
+      startColumn: 1
+      endLine: 119
+      endColumn: 1
+    - path_from_root: "libexif/apple/exif-mnote-data-apple.c"
+      startLine: 162
+      startColumn: 1
+      endLine: 164
+      endColumn: 1
+
+pov:
+  harness: 'exif_from_data_fuzzer'
+  blob: 'data.bin'
+
+patch:
+  good: 'good_patch.diff'
+  bad: ~
diff --git a/libexif/Makefile.am b/libexif/Makefile.am
index 943894a..cbff1b4 100644
--- a/libexif/Makefile.am
+++ b/libexif/Makefile.am
@@ -2,6 +2,7 @@ EXTRA_DIST =
 lib_LTLIBRARIES =
 noinst_LTLIBRARIES =
 
+include apple/Makefile-files
 include canon/Makefile-files
 include fuji/Makefile-files
 include olympus/Makefile-files
@@ -35,12 +36,14 @@ libexif_la_SOURCES =		\
 
 libexif_la_DEPENDENCIES = \
 	$(srcdir)/libexif.sym \
+	libmnote-apple.la		\
 	libmnote-canon.la		\
 	libmnote-fuji.la		\
 	libmnote-olympus.la	\
 	libmnote-pentax.la
 libexif_la_LIBADD =			\
 	$(LTLIBINTL)			\
+	libmnote-apple.la		\
 	libmnote-canon.la		\
 	libmnote-fuji.la	\
 	libmnote-olympus.la	\
diff --git a/libexif/apple/.gitignore b/libexif/apple/.gitignore
new file mode 100644
index 0000000..8550dbf
--- /dev/null
+++ b/libexif/apple/.gitignore
@@ -0,0 +1,6 @@
+Makefile
+Makefile.in
+.deps
+.libs
+*.la
+*.lo
diff --git a/libexif/apple/Makefile-files b/libexif/apple/Makefile-files
new file mode 100644
index 0000000..ead1b3c
--- /dev/null
+++ b/libexif/apple/Makefile-files
@@ -0,0 +1,7 @@
+# -*- Makefile -*-
+noinst_LTLIBRARIES += libmnote-apple.la
+libmnote_apple_la_SOURCES = \
+    apple/mnote-apple-entry.c apple/mnote-apple-entry.h \
+    apple/exif-mnote-data-apple.c apple/exif-mnote-data-apple.h \
+    apple/mnote-apple-tag.c apple/mnote-apple-tag.h
+libmnote_apple_la_LIBADD = $(LTLIBINTL)
diff --git a/libexif/apple/exif-mnote-data-apple.c b/libexif/apple/exif-mnote-data-apple.c
new file mode 100644
index 0000000..da43eb4
--- /dev/null
+++ b/libexif/apple/exif-mnote-data-apple.c
@@ -0,0 +1,277 @@
+/* exif-mnote-data-apple.c
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#include <config.h>
+#include "exif-mnote-data-apple.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <libexif/exif-data.h>
+#include <libexif/exif-utils.h>
+
+static void
+exif_mnote_data_apple_free(ExifMnoteData *md) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+    unsigned int i;
+
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (!d) {
+        return;
+    }
+
+    if (d->entries) {
+        for (i = 0; i < d->count; i++) {
+            if (d->entries[i].data) {
+                exif_mem_free(md->mem, d->entries[i].data);
+            }
+        }
+        exif_mem_free(md->mem, d->entries);
+        d->entries = NULL;
+        d->count = 0;
+    }
+
+    return;
+}
+
+static void
+exif_mnote_data_apple_load(ExifMnoteData *md, const unsigned char *buf, unsigned int buf_size) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+    unsigned int tcount, i;
+    unsigned int dsize;
+    unsigned int ofs, dofs;
+
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (!d || !buf || (buf_size < 6 + 16)) {
+        exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                 "ExifMnoteDataApple", "Short MakerNote");
+        return;
+    }
+
+    /* Start of interesting data */
+    ofs = d->offset + 6;
+
+    if ((buf[ofs + 12] == 'M') && (buf[ofs + 13] == 'M')) {
+        d->order = EXIF_BYTE_ORDER_MOTOROLA;
+    } else if ((buf[ofs + 12] == 'I') && (buf[ofs + 13] == 'I')) {
+        d->order = EXIF_BYTE_ORDER_INTEL;
+    } else {
+        exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                "ExifMnoteDataApple", "Unrecognized byte order");
+        /*printf("%s(%d)\n", __FUNCTION__, __LINE__);*/
+        return;
+    }
+
+    tcount = (unsigned int) exif_get_short(buf + ofs + 14, d->order);
+
+    /* Sanity check the offset */
+    if (buf_size < 6 + 16 + tcount * 6 + 4) {
+        exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                 "ExifMnoteDataApple", "Short MakerNote");
+        /*printf("%s(%d)\n", __FUNCTION__, __LINE__);*/
+        return;
+    }
+
+    /* printf("%s(%d): total %d tags\n", __FUNCTION__, __LINE__, tcount); */
+
+    ofs += 16;
+
+    exif_mnote_data_apple_free(md);
+
+    /* Reserve enough space for all the possible MakerNote tags */
+    d->entries = exif_mem_alloc(md->mem, sizeof(MnoteAppleEntry) * tcount);
+    if (!d->entries) {
+        EXIF_LOG_NO_MEMORY(md->log, "ExifMnoteApple", sizeof(MnoteAppleEntry) * tcount);
+        /*printf("%s(%d)\n", __FUNCTION__, __LINE__);*/
+        return;
+    }
+
+    for (i = 0; i < tcount; i++) {
+        d->entries[i].tag = exif_get_short(buf + ofs, d->order);
+        d->entries[i].format = exif_get_short(buf + ofs + 2, d->order);
+        d->entries[i].components = exif_get_long(buf + ofs + 4, d->order);
+        d->entries[i].order = d->order;
+        dsize = exif_format_get_size(d->entries[i].format) * d->entries[i].components;
+        if (dsize > 4) {
+            dofs = d->offset + exif_get_long(buf + ofs + 8, d->order);
+        } else {
+            dofs = ofs + 8;
+        }
+	if (dofs > buf_size) {
+		exif_log (md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                                  "ExifMnoteApplet", "Tag size overflow detected (%u vs size %u)", dofs, buf_size);
+		continue;
+	}
+        ofs += 12;
+        d->entries[i].data = exif_mem_alloc(md->mem, dsize);
+        if (!d->entries[i].data) {
+            EXIF_LOG_NO_MEMORY(md->log, "ExifMnoteApple", dsize);
+            continue;
+        }
+        if (dofs + dsize > buf_size) {
+            exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                "ExifMnoteApplet", "Tag size overflow detected (%u vs size %u)", dofs + dsize, buf_size);
+            continue;
+        }
+        memcpy(d->entries[i].data, buf + dofs, dsize);
+        d->entries[i].size = dsize;
+    }
+    d->count = tcount;
+
+    return;
+}
+
+static void
+exif_mnote_data_apple_set_offset(ExifMnoteData *md, unsigned int o) {
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (md) {
+        ((ExifMnoteDataApple *) md)->offset = o;
+    }
+
+    return;
+}
+
+static void
+exif_mnote_data_apple_set_byte_order(ExifMnoteData *md , ExifByteOrder o) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+    unsigned int i;
+
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (!d || d->order == o) {
+        return;
+    }
+
+    for (i = 0; i < d->count; i++) {
+        if (d->entries[i].size != (exif_format_get_size(d->entries[i].format) * d->entries[i].components)) {
+            continue;
+        }
+        exif_array_set_byte_order(d->entries[i].format, d->entries[i].data,
+                                  d->entries[i].components, d->entries[i].order, o);
+        d->entries[i].order = o;
+    }
+    d->order = o;
+
+    return;
+}
+
+static unsigned int
+exif_mnote_data_apple_count(ExifMnoteData *md){
+    /*printf("%s\n", __FUNCTION__);*/
+
+    return md ? ((ExifMnoteDataApple *) md)->count : 0;
+}
+
+static unsigned int
+exif_mnote_data_apple_get_id(ExifMnoteData *md, unsigned int i) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!d || (d->count <= i)) {
+        return 0;
+    }
+
+    return d->entries[i].tag;
+}
+
+static const char *
+exif_mnote_data_apple_get_name(ExifMnoteData *md, unsigned int i) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!d || (d->count <= i)) {
+        return NULL;
+    }
+
+    return mnote_apple_tag_get_name(d->entries[i].tag);
+}
+
+static const char *
+exif_mnote_data_apple_get_title(ExifMnoteData *md, unsigned int i) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!d || (d->count <= i)) {
+        return NULL;
+    }
+
+    return mnote_apple_tag_get_title(d->entries[i].tag);
+}
+
+static const char *
+exif_mnote_data_apple_get_description(ExifMnoteData *md, unsigned int i) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!d || (d->count <= i)) {
+        return NULL;
+    }
+
+    return mnote_apple_tag_get_description(d->entries[i].tag);
+}
+
+static char *
+exif_mnote_data_apple_get_value(ExifMnoteData *md, unsigned int i, char *val, unsigned int maxlen) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!val || !d || (d->count <= i)) {
+        return NULL;
+    }
+
+    return mnote_apple_entry_get_value(&d->entries[i], val, maxlen);
+}
+
+int
+exif_mnote_data_apple_identify(const ExifData *ed, const ExifEntry *e) {
+    if (e->size < strlen("Apple iOS")+1)
+        return 0;
+    return !memcmp((const char*) e->data, "Apple iOS", strlen("Apple iOS"));
+}
+
+ExifMnoteData *
+exif_mnote_data_apple_new(ExifMem *mem) {
+    ExifMnoteData *md;
+
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (!mem) {
+        return NULL;
+    }
+
+    md = exif_mem_alloc(mem, sizeof(ExifMnoteDataApple));
+    if (!md) {
+        return NULL;
+    }
+
+    exif_mnote_data_construct(md, mem);
+
+    md->methods.free = exif_mnote_data_apple_free;
+    md->methods.load = exif_mnote_data_apple_load;
+    md->methods.set_offset = exif_mnote_data_apple_set_offset;
+    md->methods.set_byte_order = exif_mnote_data_apple_set_byte_order;
+    md->methods.count = exif_mnote_data_apple_count;
+    md->methods.get_id = exif_mnote_data_apple_get_id;
+    md->methods.get_name = exif_mnote_data_apple_get_name;
+    md->methods.get_title = exif_mnote_data_apple_get_title;
+    md->methods.get_description = exif_mnote_data_apple_get_description;
+    md->methods.get_value = exif_mnote_data_apple_get_value;
+
+    return md;
+}
diff --git a/libexif/apple/exif-mnote-data-apple.h b/libexif/apple/exif-mnote-data-apple.h
new file mode 100644
index 0000000..7fc7e8e
--- /dev/null
+++ b/libexif/apple/exif-mnote-data-apple.h
@@ -0,0 +1,44 @@
+/* mnote-apple-data.h
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#ifndef __MNOTE_APPLE_CONTENT_H__
+#define __MNOTE_APPLE_CONTENT_H__
+
+#include <libexif/exif-byte-order.h>
+#include <libexif/exif-data.h>
+#include <libexif/exif-mem.h>
+#include <libexif/exif-mnote-data-priv.h>
+#include <libexif/apple/mnote-apple-entry.h>
+
+typedef struct _ExifMnoteDataApple ExifMnoteDataApple;
+
+struct _ExifMnoteDataApple {
+    ExifMnoteData parent;
+    ExifByteOrder order;
+    unsigned int offset;
+    MnoteAppleEntry *entries;
+    unsigned int count;
+};
+
+int exif_mnote_data_apple_identify(const ExifData *, const ExifEntry *);
+
+ExifMnoteData *exif_mnote_data_apple_new(ExifMem *);
+
+#endif /* __MNOTE_APPLE_CONTENT_H__ */
diff --git a/libexif/apple/mnote-apple-entry.c b/libexif/apple/mnote-apple-entry.c
new file mode 100644
index 0000000..e24eda8
--- /dev/null
+++ b/libexif/apple/mnote-apple-entry.c
@@ -0,0 +1,155 @@
+/* mnote-apple-entry.c
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#include <config.h>
+#include "mnote-apple-entry.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <libexif/exif-entry.h>
+#include <libexif/exif-format.h>
+#include <libexif/exif-utils.h>
+#include <libexif/i18n.h>
+
+char *
+mnote_apple_entry_get_value(MnoteAppleEntry *entry, char *v, unsigned int maxlen) {
+    ExifLong  vl;
+    ExifSLong vsl;
+    ExifShort vs;
+    ExifSShort vss;
+    ExifRational vr;
+    ExifSRational vsr;
+    size_t size;
+    unsigned char *data;
+
+    if (!entry)
+        return NULL;
+
+    memset(v, 0, maxlen);
+    maxlen--;
+
+    size = entry->size;
+    data = entry->data;
+    switch (entry->tag) {
+    case MNOTE_APPLE_TAG_HDR:
+	if (size < 4) return NULL;
+	if (entry->format != EXIF_FORMAT_SLONG) return NULL;
+	if (entry->components != 1) return NULL;
+
+        vsl = exif_get_slong(data, entry->order);
+        snprintf(v, maxlen, "%d", vsl);
+        break;
+    case MNOTE_APPLE_TAG_IMAGE_UNIQUE_ID:
+    case MNOTE_APPLE_TAG_BURST_UUID:
+    case MNOTE_APPLE_TAG_MEDIA_GROUP_UUID:
+	if (entry->format != EXIF_FORMAT_ASCII) return NULL;
+	strncpy (v, (char *) data, MIN (maxlen-1, size));
+	v[MIN (maxlen-1, size)] = 0;
+        break;
+    default:
+	switch (entry->format) {
+	case EXIF_FORMAT_ASCII:
+	    strncpy (v, (char *)data, MIN(maxlen, size));
+	    break;
+	case EXIF_FORMAT_SHORT: {
+	    size_t i, len = 0;
+
+	    for(i=0; i<entry->components; i++) {
+		if (size < 2)
+		    break;
+		if (len > maxlen)
+		    break;
+		vs = exif_get_short (data, entry->order);
+		snprintf (v+len, maxlen-len, "%hu ", vs);
+		len = strlen(v);
+		data += 2;
+		size -= 2;
+	    }
+	    }
+	    break;
+	case EXIF_FORMAT_SSHORT: {
+	    size_t i, len = 0;
+	    for(i=0; i<entry->components; i++) {
+		if (size < 2)
+		    break;
+		if (len > maxlen)
+		    break;
+		vss = exif_get_sshort (data, entry->order);
+		snprintf (v+len, maxlen-len, "%hi ", vss);
+		len = strlen(v);
+		data += 2;
+		size -= 2;
+	    }
+	}
+	break;
+        case EXIF_FORMAT_LONG: {
+	    size_t i, len = 0;
+	    for(i=0; i<entry->components; i++) {
+		if (size < 4)
+		    break;
+		if (len > maxlen)
+		    break;
+		vl = exif_get_long (data, entry->order);
+		snprintf (v+len, maxlen-len, "%lu ", (long unsigned) vl);
+		len = strlen(v);
+		data += 4;
+		size -= 4;
+	    }
+	    }
+	    break;
+	case EXIF_FORMAT_SLONG: {
+	    size_t i, len = 0;
+	    for(i=0; i<entry->components; i++) {
+		if (size < 4)
+		    break;
+		if (len > maxlen)
+		    break;
+		vsl = exif_get_slong (data, entry->order);
+		snprintf (v+len, maxlen-len, "%li ", (long int) vsl);
+		len = strlen(v);
+		data += 4;
+		size -= 4;
+	    }
+	    }
+	    break;
+	case EXIF_FORMAT_RATIONAL:
+	    vr = exif_get_rational (data, entry->order);
+	    if (!vr.denominator) break;
+	    snprintf (v, maxlen, "%2.4f", (double) vr.numerator /
+					    vr.denominator);
+	    break;
+	case EXIF_FORMAT_SRATIONAL:
+	    vsr = exif_get_srational (data, entry->order);
+	    if (!vsr.denominator) break;
+	    snprintf (v, maxlen, "%2.4f", (double) vsr.numerator /
+		  vsr.denominator);
+	    break;
+	case EXIF_FORMAT_UNDEFINED:
+	default:
+	    snprintf (v, maxlen, _("%i bytes unknown data"), entry->size);
+	    break;
+        }
+	break;
+     }
+
+     return v;
+}
diff --git a/libexif/apple/mnote-apple-entry.h b/libexif/apple/mnote-apple-entry.h
new file mode 100644
index 0000000..e477efd
--- /dev/null
+++ b/libexif/apple/mnote-apple-entry.h
@@ -0,0 +1,41 @@
+/* mnote-apple-entry.h
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#ifndef __MNOTE_APPLE_ENTRY_H__
+#define __MNOTE_APPLE_ENTRY_H__
+
+#include <libexif/exif-byte-order.h>
+#include <libexif/exif-format.h>
+#include <libexif/apple/mnote-apple-tag.h>
+
+typedef struct _MnoteAppleEntry MnoteAppleEntry;
+
+struct _MnoteAppleEntry {
+    MnoteAppleTag tag;
+    ExifFormat format;
+    unsigned long components;
+    unsigned char *data;
+    unsigned int size;
+    ExifByteOrder order;
+};
+
+char *mnote_apple_entry_get_value(MnoteAppleEntry *, char *, unsigned int);
+
+#endif /* __MNOTE_APPLE_ENTRY_H__ */
diff --git a/libexif/apple/mnote-apple-tag.c b/libexif/apple/mnote-apple-tag.c
new file mode 100644
index 0000000..066f674
--- /dev/null
+++ b/libexif/apple/mnote-apple-tag.c
@@ -0,0 +1,89 @@
+/* mnote-apple-tag.c:
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#include <config.h>
+#include "mnote-apple-tag.h"
+
+#include <libexif/i18n.h>
+#include <libexif/exif-utils.h>
+
+#include <stdlib.h>
+
+static const struct {
+    MnoteAppleTag tag;
+    const char *name;
+    const char *title;
+    const char *description;
+} table[] = {
+#ifndef NO_VERBOSE_TAG_STRINGS
+    {MNOTE_APPLE_TAG_HDR, "HDR", N_("HDR Mode"), ""},
+    {MNOTE_APPLE_TAG_RUNTIME, "RUNTIME", N_("Runtime"), ""},
+    {MNOTE_APPLE_TAG_ACCELERATION_VECTOR, "ACCELERATION_VECTOR", N_("Acceleration Vector"), ""},
+    {MNOTE_APPLE_TAG_HDR, "HDR", N_("HDR"), ""},
+    {MNOTE_APPLE_TAG_BURST_UUID, "BURST_UUID", N_("Burst UUID"), ""},
+    {MNOTE_APPLE_TAG_MEDIA_GROUP_UUID, "MEDIA_GROUP_UUID", N_("Media Group UUID"), ""},
+    {MNOTE_APPLE_TAG_IMAGE_UNIQUE_ID, "IMAGE_UNIQUE_ID", N_("Image Unique ID"), ""},
+#endif
+    {0, NULL, NULL, NULL}
+};
+
+const char *
+mnote_apple_tag_get_name(MnoteAppleTag t) {
+    unsigned int i;
+
+    for (i = 0; i < sizeof (table) / sizeof (table[0]); i++) {
+        if (table[i].tag == t) {
+            return table[i].name;
+        }
+    }
+
+    return NULL;
+}
+
+const char *
+mnote_apple_tag_get_title(MnoteAppleTag t) {
+    unsigned int i;
+
+    (void) bindtextdomain(GETTEXT_PACKAGE, LOCALEDIR);
+    for (i = 0; i < sizeof (table) / sizeof (table[0]); i++) {
+        if (table[i].tag == t) {
+            return _(table[i].title);
+        }
+    }
+
+    return NULL;
+}
+
+const char *
+mnote_apple_tag_get_description(MnoteAppleTag t) {
+    unsigned int i;
+
+    for (i = 0; i < sizeof (table) / sizeof (table[0]); i++) {
+        if (table[i].tag == t) {
+            if (!table[i].description || !*table[i].description) {
+                return "";
+            }
+            (void) bindtextdomain(GETTEXT_PACKAGE, LOCALEDIR);
+            return _(table[i].description);
+        }
+    }
+
+    return NULL;
+}
diff --git a/libexif/apple/mnote-apple-tag.h b/libexif/apple/mnote-apple-tag.h
new file mode 100644
index 0000000..5033943
--- /dev/null
+++ b/libexif/apple/mnote-apple-tag.h
@@ -0,0 +1,46 @@
+/* mnote-apple-tag.h
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#ifndef __MNOTE_APPLE_TAG_H__
+#define __MNOTE_APPLE_TAG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+enum _MnoteAppleTag {
+    MNOTE_APPLE_TAG_RUNTIME		= 0x3,
+    MNOTE_APPLE_TAG_ACCELERATION_VECTOR	= 0x9,
+    MNOTE_APPLE_TAG_HDR			= 0xA,
+    MNOTE_APPLE_TAG_BURST_UUID 		= 0xB,
+    MNOTE_APPLE_TAG_MEDIA_GROUP_UUID	= 0x11,
+    MNOTE_APPLE_TAG_IMAGE_UNIQUE_ID	= 0x15,
+};
+typedef enum _MnoteAppleTag MnoteAppleTag;
+
+const char *mnote_apple_tag_get_name(MnoteAppleTag);
+const char *mnote_apple_tag_get_title(MnoteAppleTag);
+const char *mnote_apple_tag_get_description(MnoteAppleTag);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __MNOTE_APPLE_TAG_H__ */
diff --git a/libexif/exif-data.c b/libexif/exif-data.c
index 906bda6..70f5c01 100644
--- a/libexif/exif-data.c
+++ b/libexif/exif-data.c
@@ -30,6 +30,7 @@
 #include <libexif/i18n.h>
 #include <libexif/exif-system.h>
 
+#include <libexif/apple/exif-mnote-data-apple.h>
 #include <libexif/canon/exif-mnote-data-canon.h>
 #include <libexif/fuji/exif-mnote-data-fuji.h>
 #include <libexif/olympus/exif-mnote-data-olympus.h>
@@ -816,6 +817,10 @@ interpret_maker_note(ExifData *data, const unsigned char *d, unsigned int ds)
 		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,
 			"ExifData", "Pentax MakerNote variant type %d", mnoteid);
 		data->priv->md = exif_mnote_data_pentax_new (data->priv->mem);
+	} else if ((mnoteid = exif_mnote_data_apple_identify (data, e)) != 0) {
+		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,
+			"ExifData", "Apple MakerNote variant type %d", mnoteid);
+		data->priv->md = exif_mnote_data_apple_new (data->priv->mem);
 	}
 
 	/* 
diff --git a/libexif/exif-loader.c b/libexif/exif-loader.c
index 5d78b0a..009860e 100644
--- a/libexif/exif-loader.c
+++ b/libexif/exif-loader.c
@@ -235,7 +235,7 @@ exif_loader_write (ExifLoader *eld, unsigned char *buf, unsigned int len)
 		break;
 	}
 
-	for (i = 0; i < sizeof (eld->b); i++)
+	for (i = 0; i < sizeof (eld->b); i++) {
 		switch (eld->state) {
 		case EL_EXIF_FOUND:
 			if (!exif_loader_copy (eld, eld->b + i,
@@ -243,9 +243,19 @@ exif_loader_write (ExifLoader *eld, unsigned char *buf, unsigned int len)
 				return 0;
 			return exif_loader_copy (eld, buf, len);
 		case EL_SKIP_BYTES:
-			eld->size--;
-			if (!eld->size) 
-				eld->state = EL_READ;
+			switch (eld->size) {
+                            case 0:
+			        eld->state = EL_READ;
+				i--;   // reprocess this byte
+				break;
+                            case 1:
+                                eld->size = 0;
+			        eld->state = EL_READ;
+				break;
+                            default:
+                                eld->size--;
+				break;
+			}
 			break;
 
 		case EL_READ_SIZE_BYTE_24:
@@ -265,12 +275,20 @@ exif_loader_write (ExifLoader *eld, unsigned char *buf, unsigned int len)
 			switch (eld->data_format) {
 			case EL_DATA_FORMAT_JPEG:
 				eld->state = EL_SKIP_BYTES;
-				eld->size -= 2;
+				if (eld->size < 2) {
+				    // Actually it's malformed...
+				    eld->size = 0;
+				} else
+				    eld->size -= 2;
 				break;
 			case EL_DATA_FORMAT_FUJI_RAW:
 				eld->data_format = EL_DATA_FORMAT_EXIF;
 				eld->state = EL_SKIP_BYTES;
-				eld->size -= 86;
+				if (eld->size < 86) {
+				    // Actually it's malformed...
+				    eld->size = 0;
+				} else
+				    eld->size -= 86;	// and put this in an else
 				break;
 			case EL_DATA_FORMAT_EXIF:
 				eld->state = EL_EXIF_FOUND;
@@ -319,6 +337,7 @@ exif_loader_write (ExifLoader *eld, unsigned char *buf, unsigned int len)
 				return 0;
 			}
 		}
+	}
 
 	/*
 	 * If we reach this point, the buffer has not been big enough
