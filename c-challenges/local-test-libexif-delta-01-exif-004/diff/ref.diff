diff --git a/libexif/Makefile.am b/libexif/Makefile.am
index 943894a..cbff1b4 100644
--- a/libexif/Makefile.am
+++ b/libexif/Makefile.am
@@ -2,6 +2,7 @@ EXTRA_DIST =
 lib_LTLIBRARIES =
 noinst_LTLIBRARIES =
 
+include apple/Makefile-files
 include canon/Makefile-files
 include fuji/Makefile-files
 include olympus/Makefile-files
@@ -35,12 +36,14 @@ libexif_la_SOURCES =		\
 
 libexif_la_DEPENDENCIES = \
 	$(srcdir)/libexif.sym \
+	libmnote-apple.la		\
 	libmnote-canon.la		\
 	libmnote-fuji.la		\
 	libmnote-olympus.la	\
 	libmnote-pentax.la
 libexif_la_LIBADD =			\
 	$(LTLIBINTL)			\
+	libmnote-apple.la		\
 	libmnote-canon.la		\
 	libmnote-fuji.la	\
 	libmnote-olympus.la	\
diff --git a/libexif/apple/.gitignore b/libexif/apple/.gitignore
new file mode 100644
index 0000000..8550dbf
--- /dev/null
+++ b/libexif/apple/.gitignore
@@ -0,0 +1,6 @@
+Makefile
+Makefile.in
+.deps
+.libs
+*.la
+*.lo
diff --git a/libexif/apple/Makefile-files b/libexif/apple/Makefile-files
new file mode 100644
index 0000000..ead1b3c
--- /dev/null
+++ b/libexif/apple/Makefile-files
@@ -0,0 +1,7 @@
+# -*- Makefile -*-
+noinst_LTLIBRARIES += libmnote-apple.la
+libmnote_apple_la_SOURCES = \
+    apple/mnote-apple-entry.c apple/mnote-apple-entry.h \
+    apple/exif-mnote-data-apple.c apple/exif-mnote-data-apple.h \
+    apple/mnote-apple-tag.c apple/mnote-apple-tag.h
+libmnote_apple_la_LIBADD = $(LTLIBINTL)
diff --git a/libexif/apple/exif-mnote-data-apple.c b/libexif/apple/exif-mnote-data-apple.c
new file mode 100644
index 0000000..7b2edad
--- /dev/null
+++ b/libexif/apple/exif-mnote-data-apple.c
@@ -0,0 +1,277 @@
+/* exif-mnote-data-apple.c
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#include <config.h>
+#include "exif-mnote-data-apple.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <libexif/exif-data.h>
+#include <libexif/exif-utils.h>
+
+static void
+exif_mnote_data_apple_free(ExifMnoteData *md) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+    unsigned int i;
+
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (!d) {
+        return;
+    }
+
+    if (d->entries) {
+        for (i = 0; i < d->count; i++) {
+            if (d->entries[i].data) {
+                exif_mem_free(md->mem, d->entries[i].data);
+            }
+        }
+        exif_mem_free(md->mem, d->entries);
+        d->entries = NULL;
+        d->count = 0;
+    }
+
+    return;
+}
+
+static void
+exif_mnote_data_apple_load(ExifMnoteData *md, const unsigned char *buf, unsigned int buf_size) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+    unsigned int tcount, i;
+    unsigned int dsize;
+    unsigned int ofs, dofs;
+
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (!d || !buf || (buf_size < 6 + 16)) {
+        exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                 "ExifMnoteDataApple", "Short MakerNote");
+        return;
+    }
+
+    /* Start of interesting data */
+    ofs = d->offset + 6;
+
+    if ((buf[ofs + 12] == 'M') && (buf[ofs + 13] == 'M')) {
+        d->order = EXIF_BYTE_ORDER_MOTOROLA;
+    } else if ((buf[ofs + 12] == 'I') && (buf[ofs + 13] == 'I')) {
+        d->order = EXIF_BYTE_ORDER_INTEL;
+    } else {
+        exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                "ExifMnoteDataApple", "Unrecognized byte order");
+        /*printf("%s(%d)\n", __FUNCTION__, __LINE__);*/
+        return;
+    }
+
+    tcount = (unsigned int) exif_get_short(buf + ofs + 14, d->order);
+
+    /* Sanity check the offset */
+    if (buf_size < d->offset + 6 + 16 + tcount * 12 + 4) {
+        exif_log(md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                 "ExifMnoteDataApple", "Short MakerNote");
+        /*printf("%s(%d)\n", __FUNCTION__, __LINE__);*/
+        return;
+    }
+    memset(d->entries, 0, sizeof(MnoteAppleEntry) * tcount);
+
+    /* printf("%s(%d): total %d tags\n", __FUNCTION__, __LINE__, tcount); */
+
+    ofs += 16;
+
+    exif_mnote_data_apple_free(md);
+
+    /* Reserve enough space for all the possible MakerNote tags */
+    d->entries = exif_mem_alloc(md->mem, sizeof(MnoteAppleEntry) * tcount);
+    if (!d->entries) {
+        EXIF_LOG_NO_MEMORY(md->log, "ExifMnoteApple", sizeof(MnoteAppleEntry) * tcount);
+        /*printf("%s(%d)\n", __FUNCTION__, __LINE__);*/
+        return;
+    }
+
+    for (i = 0; i < tcount; i++) {
+	if (ofs + 12 > buf_size) {
+		exif_log (md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                                  "ExifMnoteApplet", "Tag size overflow detected (%u vs size %u)", ofs + 12, buf_size);
+		break;
+	}
+        d->entries[i].tag = exif_get_short(buf + ofs, d->order);
+        d->entries[i].format = exif_get_short(buf + ofs + 2, d->order);
+        d->entries[i].components = exif_get_long(buf + ofs + 4, d->order);
+        d->entries[i].order = d->order;
+        dsize = exif_format_get_size(d->entries[i].format) * d->entries[i].components;
+        if (dsize > 4) {
+            dofs = d->offset + exif_get_long(buf + ofs + 8, d->order);
+        } else {
+            dofs = ofs + 8;
+        }
+	if (dofs > buf_size) {
+		exif_log (md->log, EXIF_LOG_CODE_CORRUPT_DATA,
+                                  "ExifMnoteApplet", "Tag size overflow detected (%u vs size %u)", dofs, buf_size);
+		continue;
+	}
+        ofs += 12;
+        d->entries[i].data = exif_mem_alloc(md->mem, dsize);
+        if (!d->entries[i].data) {
+            EXIF_LOG_NO_MEMORY(md->log, "ExifMnoteApple", dsize);
+            continue;
+        }
+        memcpy(d->entries[i].data, buf + dofs, dsize);
+        d->entries[i].size = dsize;
+    }
+    d->count = tcount;
+
+    return;
+}
+
+static void
+exif_mnote_data_apple_set_offset(ExifMnoteData *md, unsigned int o) {
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (md) {
+        ((ExifMnoteDataApple *) md)->offset = o;
+    }
+
+    return;
+}
+
+static void
+exif_mnote_data_apple_set_byte_order(ExifMnoteData *md , ExifByteOrder o) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+    unsigned int i;
+
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (!d || d->order == o) {
+        return;
+    }
+
+    for (i = 0; i < d->count; i++) {
+	if (d->entries[i].components && (d->entries[i].size/d->entries[i].components < exif_format_get_size (d->entries[i].format)))
+		continue;
+        exif_array_set_byte_order(d->entries[i].format, d->entries[i].data,
+                                  d->entries[i].components, d->entries[i].order, o);
+        d->entries[i].order = o;
+    }
+    d->order = o;
+
+    return;
+}
+
+static unsigned int
+exif_mnote_data_apple_count(ExifMnoteData *md){
+    /*printf("%s\n", __FUNCTION__);*/
+
+    return md ? ((ExifMnoteDataApple *) md)->count : 0;
+}
+
+static unsigned int
+exif_mnote_data_apple_get_id(ExifMnoteData *md, unsigned int i) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!d || (d->count <= i)) {
+        return 0;
+    }
+
+    return d->entries[i].tag;
+}
+
+static const char *
+exif_mnote_data_apple_get_name(ExifMnoteData *md, unsigned int i) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!d || (d->count <= i)) {
+        return NULL;
+    }
+
+    return mnote_apple_tag_get_name(d->entries[i].tag);
+}
+
+static const char *
+exif_mnote_data_apple_get_title(ExifMnoteData *md, unsigned int i) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!d || (d->count <= i)) {
+        return NULL;
+    }
+
+    return mnote_apple_tag_get_title(d->entries[i].tag);
+}
+
+static const char *
+exif_mnote_data_apple_get_description(ExifMnoteData *md, unsigned int i) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!d || (d->count <= i)) {
+        return NULL;
+    }
+
+    return mnote_apple_tag_get_description(d->entries[i].tag);
+}
+
+static char *
+exif_mnote_data_apple_get_value(ExifMnoteData *md, unsigned int i, char *val, unsigned int maxlen) {
+    ExifMnoteDataApple *d = (ExifMnoteDataApple *) md;
+
+    if (!val || !d || (d->count <= i)) {
+        return NULL;
+    }
+
+    return mnote_apple_entry_get_value(&d->entries[i], val, maxlen);
+}
+
+int
+exif_mnote_data_apple_identify(const ExifData *ed, const ExifEntry *e) {
+    if (e->size < strlen("Apple iOS")+1)
+        return 0;
+    return !memcmp((const char*) e->data, "Apple iOS", strlen("Apple iOS"));
+}
+
+ExifMnoteData *
+exif_mnote_data_apple_new(ExifMem *mem) {
+    ExifMnoteData *md;
+
+    /*printf("%s\n", __FUNCTION__);*/
+
+    if (!mem) {
+        return NULL;
+    }
+
+    md = exif_mem_alloc(mem, sizeof(ExifMnoteDataApple));
+    if (!md) {
+        return NULL;
+    }
+
+    exif_mnote_data_construct(md, mem);
+
+    md->methods.free = exif_mnote_data_apple_free;
+    md->methods.load = exif_mnote_data_apple_load;
+    md->methods.set_offset = exif_mnote_data_apple_set_offset;
+    md->methods.set_byte_order = exif_mnote_data_apple_set_byte_order;
+    md->methods.count = exif_mnote_data_apple_count;
+    md->methods.get_id = exif_mnote_data_apple_get_id;
+    md->methods.get_name = exif_mnote_data_apple_get_name;
+    md->methods.get_title = exif_mnote_data_apple_get_title;
+    md->methods.get_description = exif_mnote_data_apple_get_description;
+    md->methods.get_value = exif_mnote_data_apple_get_value;
+
+    return md;
+}
diff --git a/libexif/apple/exif-mnote-data-apple.h b/libexif/apple/exif-mnote-data-apple.h
new file mode 100644
index 0000000..7fc7e8e
--- /dev/null
+++ b/libexif/apple/exif-mnote-data-apple.h
@@ -0,0 +1,44 @@
+/* mnote-apple-data.h
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#ifndef __MNOTE_APPLE_CONTENT_H__
+#define __MNOTE_APPLE_CONTENT_H__
+
+#include <libexif/exif-byte-order.h>
+#include <libexif/exif-data.h>
+#include <libexif/exif-mem.h>
+#include <libexif/exif-mnote-data-priv.h>
+#include <libexif/apple/mnote-apple-entry.h>
+
+typedef struct _ExifMnoteDataApple ExifMnoteDataApple;
+
+struct _ExifMnoteDataApple {
+    ExifMnoteData parent;
+    ExifByteOrder order;
+    unsigned int offset;
+    MnoteAppleEntry *entries;
+    unsigned int count;
+};
+
+int exif_mnote_data_apple_identify(const ExifData *, const ExifEntry *);
+
+ExifMnoteData *exif_mnote_data_apple_new(ExifMem *);
+
+#endif /* __MNOTE_APPLE_CONTENT_H__ */
diff --git a/libexif/apple/mnote-apple-entry.c b/libexif/apple/mnote-apple-entry.c
new file mode 100644
index 0000000..e24eda8
--- /dev/null
+++ b/libexif/apple/mnote-apple-entry.c
@@ -0,0 +1,155 @@
+/* mnote-apple-entry.c
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#include <config.h>
+#include "mnote-apple-entry.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <libexif/exif-entry.h>
+#include <libexif/exif-format.h>
+#include <libexif/exif-utils.h>
+#include <libexif/i18n.h>
+
+char *
+mnote_apple_entry_get_value(MnoteAppleEntry *entry, char *v, unsigned int maxlen) {
+    ExifLong  vl;
+    ExifSLong vsl;
+    ExifShort vs;
+    ExifSShort vss;
+    ExifRational vr;
+    ExifSRational vsr;
+    size_t size;
+    unsigned char *data;
+
+    if (!entry)
+        return NULL;
+
+    memset(v, 0, maxlen);
+    maxlen--;
+
+    size = entry->size;
+    data = entry->data;
+    switch (entry->tag) {
+    case MNOTE_APPLE_TAG_HDR:
+	if (size < 4) return NULL;
+	if (entry->format != EXIF_FORMAT_SLONG) return NULL;
+	if (entry->components != 1) return NULL;
+
+        vsl = exif_get_slong(data, entry->order);
+        snprintf(v, maxlen, "%d", vsl);
+        break;
+    case MNOTE_APPLE_TAG_IMAGE_UNIQUE_ID:
+    case MNOTE_APPLE_TAG_BURST_UUID:
+    case MNOTE_APPLE_TAG_MEDIA_GROUP_UUID:
+	if (entry->format != EXIF_FORMAT_ASCII) return NULL;
+	strncpy (v, (char *) data, MIN (maxlen-1, size));
+	v[MIN (maxlen-1, size)] = 0;
+        break;
+    default:
+	switch (entry->format) {
+	case EXIF_FORMAT_ASCII:
+	    strncpy (v, (char *)data, MIN(maxlen, size));
+	    break;
+	case EXIF_FORMAT_SHORT: {
+	    size_t i, len = 0;
+
+	    for(i=0; i<entry->components; i++) {
+		if (size < 2)
+		    break;
+		if (len > maxlen)
+		    break;
+		vs = exif_get_short (data, entry->order);
+		snprintf (v+len, maxlen-len, "%hu ", vs);
+		len = strlen(v);
+		data += 2;
+		size -= 2;
+	    }
+	    }
+	    break;
+	case EXIF_FORMAT_SSHORT: {
+	    size_t i, len = 0;
+	    for(i=0; i<entry->components; i++) {
+		if (size < 2)
+		    break;
+		if (len > maxlen)
+		    break;
+		vss = exif_get_sshort (data, entry->order);
+		snprintf (v+len, maxlen-len, "%hi ", vss);
+		len = strlen(v);
+		data += 2;
+		size -= 2;
+	    }
+	}
+	break;
+        case EXIF_FORMAT_LONG: {
+	    size_t i, len = 0;
+	    for(i=0; i<entry->components; i++) {
+		if (size < 4)
+		    break;
+		if (len > maxlen)
+		    break;
+		vl = exif_get_long (data, entry->order);
+		snprintf (v+len, maxlen-len, "%lu ", (long unsigned) vl);
+		len = strlen(v);
+		data += 4;
+		size -= 4;
+	    }
+	    }
+	    break;
+	case EXIF_FORMAT_SLONG: {
+	    size_t i, len = 0;
+	    for(i=0; i<entry->components; i++) {
+		if (size < 4)
+		    break;
+		if (len > maxlen)
+		    break;
+		vsl = exif_get_slong (data, entry->order);
+		snprintf (v+len, maxlen-len, "%li ", (long int) vsl);
+		len = strlen(v);
+		data += 4;
+		size -= 4;
+	    }
+	    }
+	    break;
+	case EXIF_FORMAT_RATIONAL:
+	    vr = exif_get_rational (data, entry->order);
+	    if (!vr.denominator) break;
+	    snprintf (v, maxlen, "%2.4f", (double) vr.numerator /
+					    vr.denominator);
+	    break;
+	case EXIF_FORMAT_SRATIONAL:
+	    vsr = exif_get_srational (data, entry->order);
+	    if (!vsr.denominator) break;
+	    snprintf (v, maxlen, "%2.4f", (double) vsr.numerator /
+		  vsr.denominator);
+	    break;
+	case EXIF_FORMAT_UNDEFINED:
+	default:
+	    snprintf (v, maxlen, _("%i bytes unknown data"), entry->size);
+	    break;
+        }
+	break;
+     }
+
+     return v;
+}
diff --git a/libexif/apple/mnote-apple-entry.h b/libexif/apple/mnote-apple-entry.h
new file mode 100644
index 0000000..e477efd
--- /dev/null
+++ b/libexif/apple/mnote-apple-entry.h
@@ -0,0 +1,41 @@
+/* mnote-apple-entry.h
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#ifndef __MNOTE_APPLE_ENTRY_H__
+#define __MNOTE_APPLE_ENTRY_H__
+
+#include <libexif/exif-byte-order.h>
+#include <libexif/exif-format.h>
+#include <libexif/apple/mnote-apple-tag.h>
+
+typedef struct _MnoteAppleEntry MnoteAppleEntry;
+
+struct _MnoteAppleEntry {
+    MnoteAppleTag tag;
+    ExifFormat format;
+    unsigned long components;
+    unsigned char *data;
+    unsigned int size;
+    ExifByteOrder order;
+};
+
+char *mnote_apple_entry_get_value(MnoteAppleEntry *, char *, unsigned int);
+
+#endif /* __MNOTE_APPLE_ENTRY_H__ */
diff --git a/libexif/apple/mnote-apple-tag.c b/libexif/apple/mnote-apple-tag.c
new file mode 100644
index 0000000..066f674
--- /dev/null
+++ b/libexif/apple/mnote-apple-tag.c
@@ -0,0 +1,89 @@
+/* mnote-apple-tag.c:
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#include <config.h>
+#include "mnote-apple-tag.h"
+
+#include <libexif/i18n.h>
+#include <libexif/exif-utils.h>
+
+#include <stdlib.h>
+
+static const struct {
+    MnoteAppleTag tag;
+    const char *name;
+    const char *title;
+    const char *description;
+} table[] = {
+#ifndef NO_VERBOSE_TAG_STRINGS
+    {MNOTE_APPLE_TAG_HDR, "HDR", N_("HDR Mode"), ""},
+    {MNOTE_APPLE_TAG_RUNTIME, "RUNTIME", N_("Runtime"), ""},
+    {MNOTE_APPLE_TAG_ACCELERATION_VECTOR, "ACCELERATION_VECTOR", N_("Acceleration Vector"), ""},
+    {MNOTE_APPLE_TAG_HDR, "HDR", N_("HDR"), ""},
+    {MNOTE_APPLE_TAG_BURST_UUID, "BURST_UUID", N_("Burst UUID"), ""},
+    {MNOTE_APPLE_TAG_MEDIA_GROUP_UUID, "MEDIA_GROUP_UUID", N_("Media Group UUID"), ""},
+    {MNOTE_APPLE_TAG_IMAGE_UNIQUE_ID, "IMAGE_UNIQUE_ID", N_("Image Unique ID"), ""},
+#endif
+    {0, NULL, NULL, NULL}
+};
+
+const char *
+mnote_apple_tag_get_name(MnoteAppleTag t) {
+    unsigned int i;
+
+    for (i = 0; i < sizeof (table) / sizeof (table[0]); i++) {
+        if (table[i].tag == t) {
+            return table[i].name;
+        }
+    }
+
+    return NULL;
+}
+
+const char *
+mnote_apple_tag_get_title(MnoteAppleTag t) {
+    unsigned int i;
+
+    (void) bindtextdomain(GETTEXT_PACKAGE, LOCALEDIR);
+    for (i = 0; i < sizeof (table) / sizeof (table[0]); i++) {
+        if (table[i].tag == t) {
+            return _(table[i].title);
+        }
+    }
+
+    return NULL;
+}
+
+const char *
+mnote_apple_tag_get_description(MnoteAppleTag t) {
+    unsigned int i;
+
+    for (i = 0; i < sizeof (table) / sizeof (table[0]); i++) {
+        if (table[i].tag == t) {
+            if (!table[i].description || !*table[i].description) {
+                return "";
+            }
+            (void) bindtextdomain(GETTEXT_PACKAGE, LOCALEDIR);
+            return _(table[i].description);
+        }
+    }
+
+    return NULL;
+}
diff --git a/libexif/apple/mnote-apple-tag.h b/libexif/apple/mnote-apple-tag.h
new file mode 100644
index 0000000..5033943
--- /dev/null
+++ b/libexif/apple/mnote-apple-tag.h
@@ -0,0 +1,46 @@
+/* mnote-apple-tag.h
+ *
+ * Copyright (c) 2018 zhanwang-sky <zhanwang_sky@163.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA  02110-1301  USA.
+ */
+
+#ifndef __MNOTE_APPLE_TAG_H__
+#define __MNOTE_APPLE_TAG_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+enum _MnoteAppleTag {
+    MNOTE_APPLE_TAG_RUNTIME		= 0x3,
+    MNOTE_APPLE_TAG_ACCELERATION_VECTOR	= 0x9,
+    MNOTE_APPLE_TAG_HDR			= 0xA,
+    MNOTE_APPLE_TAG_BURST_UUID 		= 0xB,
+    MNOTE_APPLE_TAG_MEDIA_GROUP_UUID	= 0x11,
+    MNOTE_APPLE_TAG_IMAGE_UNIQUE_ID	= 0x15,
+};
+typedef enum _MnoteAppleTag MnoteAppleTag;
+
+const char *mnote_apple_tag_get_name(MnoteAppleTag);
+const char *mnote_apple_tag_get_title(MnoteAppleTag);
+const char *mnote_apple_tag_get_description(MnoteAppleTag);
+
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* __MNOTE_APPLE_TAG_H__ */
diff --git a/libexif/exif-data.c b/libexif/exif-data.c
index 906bda6..70f5c01 100644
--- a/libexif/exif-data.c
+++ b/libexif/exif-data.c
@@ -30,6 +30,7 @@
 #include <libexif/i18n.h>
 #include <libexif/exif-system.h>
 
+#include <libexif/apple/exif-mnote-data-apple.h>
 #include <libexif/canon/exif-mnote-data-canon.h>
 #include <libexif/fuji/exif-mnote-data-fuji.h>
 #include <libexif/olympus/exif-mnote-data-olympus.h>
@@ -816,6 +817,10 @@ interpret_maker_note(ExifData *data, const unsigned char *d, unsigned int ds)
 		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,
 			"ExifData", "Pentax MakerNote variant type %d", mnoteid);
 		data->priv->md = exif_mnote_data_pentax_new (data->priv->mem);
+	} else if ((mnoteid = exif_mnote_data_apple_identify (data, e)) != 0) {
+		exif_log (data->priv->log, EXIF_LOG_CODE_DEBUG,
+			"ExifData", "Apple MakerNote variant type %d", mnoteid);
+		data->priv->md = exif_mnote_data_apple_new (data->priv->mem);
 	}
 
 	/* 
diff --git a/libexif/exif-loader.c b/libexif/exif-loader.c
index 5d78b0a..009860e 100644
--- a/libexif/exif-loader.c
+++ b/libexif/exif-loader.c
@@ -235,7 +235,7 @@ exif_loader_write (ExifLoader *eld, unsigned char *buf, unsigned int len)
 		break;
 	}
 
-	for (i = 0; i < sizeof (eld->b); i++)
+	for (i = 0; i < sizeof (eld->b); i++) {
 		switch (eld->state) {
 		case EL_EXIF_FOUND:
 			if (!exif_loader_copy (eld, eld->b + i,
@@ -243,9 +243,19 @@ exif_loader_write (ExifLoader *eld, unsigned char *buf, unsigned int len)
 				return 0;
 			return exif_loader_copy (eld, buf, len);
 		case EL_SKIP_BYTES:
-			eld->size--;
-			if (!eld->size) 
-				eld->state = EL_READ;
+			switch (eld->size) {
+                            case 0:
+			        eld->state = EL_READ;
+				i--;   // reprocess this byte
+				break;
+                            case 1:
+                                eld->size = 0;
+			        eld->state = EL_READ;
+				break;
+                            default:
+                                eld->size--;
+				break;
+			}
 			break;
 
 		case EL_READ_SIZE_BYTE_24:
@@ -265,12 +275,20 @@ exif_loader_write (ExifLoader *eld, unsigned char *buf, unsigned int len)
 			switch (eld->data_format) {
 			case EL_DATA_FORMAT_JPEG:
 				eld->state = EL_SKIP_BYTES;
-				eld->size -= 2;
+				if (eld->size < 2) {
+				    // Actually it's malformed...
+				    eld->size = 0;
+				} else
+				    eld->size -= 2;
 				break;
 			case EL_DATA_FORMAT_FUJI_RAW:
 				eld->data_format = EL_DATA_FORMAT_EXIF;
 				eld->state = EL_SKIP_BYTES;
-				eld->size -= 86;
+				if (eld->size < 86) {
+				    // Actually it's malformed...
+				    eld->size = 0;
+				} else
+				    eld->size -= 86;	// and put this in an else
 				break;
 			case EL_DATA_FORMAT_EXIF:
 				eld->state = EL_EXIF_FOUND;
@@ -319,6 +337,7 @@ exif_loader_write (ExifLoader *eld, unsigned char *buf, unsigned int len)
 				return 0;
 			}
 		}
+	}
 
 	/*
 	 * If we reach this point, the buffer has not been big enough
