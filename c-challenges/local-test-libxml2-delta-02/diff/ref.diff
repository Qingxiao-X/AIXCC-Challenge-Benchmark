diff --git a/include/libxml/parser.h b/include/libxml/parser.h
index 6853eb0f..84099be4 100644
--- a/include/libxml/parser.h
+++ b/include/libxml/parser.h
@@ -324,6 +324,17 @@ struct _xmlParserCtxt {
     /* array of space infos */
     int *spaceTab XML_DEPRECATED_MEMBER;
 
+    /* xml:tab values */
+
+    /* Should the parser preserve tabs */
+    int *tab XML_DEPRECATED_MEMBER;
+    /* Depth of the parsing stack */
+    int tabNr XML_DEPRECATED_MEMBER;
+    /* Max depth of the parsing stack */
+    int tabMax XML_DEPRECATED_MEMBER;
+    /* array of tab infos */
+    int *tabTab XML_DEPRECATED_MEMBER;
+    
     /* to prevent entity substitution loops */
     int depth XML_DEPRECATED_MEMBER;
     /* unused */
diff --git a/include/libxml/tree.h b/include/libxml/tree.h
index 489ad031..68bdcf15 100644
--- a/include/libxml/tree.h
+++ b/include/libxml/tree.h
@@ -1110,12 +1110,17 @@ XMLPUBFUN xmlChar *
 		xmlNodeGetLang		(const xmlNode *cur);
 XMLPUBFUN int
 		xmlNodeGetSpacePreserve	(const xmlNode *cur);
+XMLPUBFUN int
+		xmlNodeGetTabBehaviour	(const xmlNode *cur);
 XMLPUBFUN int
 		xmlNodeSetLang		(xmlNodePtr cur,
 					 const xmlChar *lang);
 XMLPUBFUN int
 		xmlNodeSetSpacePreserve (xmlNodePtr cur,
 					 int val);
+XMLPUBFUN int
+		xmlNodeSetTabBehaviour (xmlNodePtr cur,
+					 int val);
 XMLPUBFUN int
 		xmlNodeGetBaseSafe	(const xmlDoc *doc,
 					 const xmlNode *cur,
diff --git a/include/libxml/xmlerror.h b/include/libxml/xmlerror.h
index d847bfde..620ba9d3 100644
--- a/include/libxml/xmlerror.h
+++ b/include/libxml/xmlerror.h
@@ -216,6 +216,7 @@ typedef enum {
     XML_ERR_SYSTEM, /* 116 */
     XML_ERR_REDECL_PREDEF_ENTITY, /* 117 */
     XML_ERR_INT_SUBSET_NOT_FINISHED, /* 118 */
+    XML_WAR_TAB_VALUE, /* 119 */
     XML_NS_ERR_XML_NAMESPACE = 200,
     XML_NS_ERR_UNDEFINED_NAMESPACE, /* 201 */
     XML_NS_ERR_QNAME, /* 202 */
diff --git a/parser.c b/parser.c
index ad035f3c..46ddc9ab 100644
--- a/parser.c
+++ b/parser.c
@@ -2335,6 +2335,39 @@ static int spacePop(xmlParserCtxtPtr ctxt) {
     return(ret);
 }
 
+static int tabPush(xmlParserCtxtPtr ctxt, int val) {
+    if (ctxt->tabNr >= ctxt->tabMax) {
+        int *tmp;
+
+	ctxt->tabMax *= 2;
+        tmp = (int *) xmlRealloc(ctxt->tabTab,
+	                         ctxt->tabMax * sizeof(ctxt->tabTab[0]));
+        if (tmp == NULL) {
+	    xmlErrMemory(ctxt);
+	    ctxt->tabMax /=2;
+	    return(-1);
+	}
+	ctxt->tabTab = tmp;
+    }
+    ctxt->tabTab[ctxt->tabNr] = val;
+    ctxt->tab = &ctxt->tabTab[ctxt->tabNr];
+    return(ctxt->tabNr++);
+}
+
+static int tabPop(xmlParserCtxtPtr ctxt) {
+    int ret;
+    if (ctxt->tabNr <= 0) return(0);
+    ctxt->tabNr--;
+    if (ctxt->tabNr > 0)
+	ctxt->tab = &ctxt->tabTab[ctxt->tabNr - 1];
+    else
+        ctxt->tab = &ctxt->tabTab[0];
+    ret = ctxt->tabTab[ctxt->tabNr];
+    ctxt->tabTab[ctxt->tabNr] = -1;
+    return(ret);
+}
+
+
 /*
  * Macros for accessing the content. Those should be used only by the parser,
  * and not exported.
@@ -8969,6 +9002,28 @@ xmlParseAttribute2(xmlParserCtxtPtr ctxt,
                               internal_val, NULL);
             }
         }
+        /*
+         * Check that xml:tab conforms to the specification
+         */
+        if (xmlStrEqual(name, BAD_CAST "tab")) {
+            internal_val = xmlStrndup(val, *len);
+            if (internal_val == NULL)
+                goto mem_error;
+            if (xmlStrEqual(internal_val, BAD_CAST "default"))
+                *(ctxt->tab) = 0;
+            else if (xmlStrEqual(internal_val, BAD_CAST "preserve"))
+                *(ctxt->tab) = 1;
+            else if (xmlStrEqual(internal_val, BAD_CAST "expand"))
+                *(ctxt->tab) = 2;
+            else if (xmlStrEqual(internal_val, BAD_CAST "skip"))
+                *(ctxt->tab) = 3;
+            else {
+                xmlWarningMsg(ctxt, XML_WAR_TAB_VALUE,
+                              "Invalid value \"%s\" for xml:tab : \"default\", \"preserve\", \"expand\", or \"skip\" expected\n",
+                              internal_val, NULL);
+                xmlFree(internal_val);
+            }
+        }
         if (internal_val) {
             xmlFree(internal_val);
         }
diff --git a/parserInternals.c b/parserInternals.c
index 2aee44f1..d591b4eb 100644
--- a/parserInternals.c
+++ b/parserInternals.c
@@ -2799,6 +2799,18 @@ xmlInitSAXParserCtxt(xmlParserCtxtPtr ctxt, const xmlSAXHandler *sax,
     ctxt->spaceNr = 1;
     ctxt->spaceTab[0] = -1;
     ctxt->space = &ctxt->spaceTab[0];
+
+    /* Allocate the tab stack */
+    if (ctxt->tabTab == NULL) {
+	ctxt->tabTab = xmlMalloc(initialNodeTabSize * sizeof(int));
+	ctxt->tabMax = initialNodeTabSize;
+    }
+
+    if (ctxt->tabTab == NULL)
+	return(-1);
+    ctxt->tabNr = 1;
+    ctxt->tabTab[0] = -1;
+    ctxt->tab = &ctxt->tabTab[0];
     ctxt->myDoc = NULL;
     ctxt->wellFormed = 1;
     ctxt->nsWellFormed = 1;
@@ -2900,6 +2912,7 @@ xmlFreeParserCtxt(xmlParserCtxtPtr ctxt)
         xmlFreeInputStream(input);
     }
     if (ctxt->spaceTab != NULL) xmlFree(ctxt->spaceTab);
+    if (ctxt->tabTab != NULL) xmlFree(ctxt->tabTab);
     if (ctxt->nameTab != NULL) xmlFree((xmlChar * *)ctxt->nameTab);
     if (ctxt->nodeTab != NULL) xmlFree(ctxt->nodeTab);
     if (ctxt->nodeInfoTab != NULL) xmlFree(ctxt->nodeInfoTab);
diff --git a/tree.c b/tree.c
index 2df09d92..0e0cadfe 100644
--- a/tree.c
+++ b/tree.c
@@ -5186,6 +5186,99 @@ xmlNodeGetSpacePreserve(const xmlNode *cur) {
     return(-1);
 }
 
+
+/**
+ * xmlNodeSetTabBehaviour:
+ * @cur:  the node being changed
+ * @val:  the xml:tab value ("0": default, 1: "preserve", 2: "expand", 3: "skip")
+ *
+ * Set (or reset) the tab behaviour of a node, i.e. the
+ * value of the xml:tab attribute.
+ *
+ * Return 0 on success, 1 if arguments are invalid, -1 if a
+ * memory allocation failed.
+ */
+/*
+int
+xmlNodeSetTabBehaviour(xmlNodePtr cur, int val) {
+    xmlNsPtr ns;
+    xmlAttrPtr attr;
+    const char *string;
+    int res;
+
+    if ((cur == NULL) || (cur->type != XML_ELEMENT_NODE))
+        return(1);
+
+    res = xmlSearchNsByHrefSafe(cur, XML_XML_NAMESPACE, &ns);
+    if (res != 0)
+	return(res);
+
+    if (val == 0)
+        string = "default";
+    else if (val == 1)
+        string = "preserve";
+    else if (val == 1)
+        string = "expand";
+    else
+        string = "skip";
+
+    attr = xmlSetNsProp(cur, ns, BAD_CAST "tab", BAD_CAST string);
+    if (attr == NULL)
+        return(-1);
+
+    return(0);
+}*/
+
+/**
+ * xmlNodeGetTabBehaviour:
+ * @cur:  the node being checked
+ *
+ * Searches the tab behaviour of a node, i.e. the values
+ * of the xml:tab attribute or the one carried by the nearest
+ * ancestor.
+ *
+ * Returns -1 if xml:tab is not inherited, 0 if "default", 1 if "preserve",
+ * 2 if "expand", 3 if "skip"
+ */
+int
+xmlNodeGetTabBehaviour(const xmlNode *cur) {
+    xmlChar *tab;
+        int res;
+
+    if ((cur == NULL) || (cur->type != XML_ELEMENT_NODE))
+        return(-1);
+
+    while (cur != NULL) {
+	res = xmlNodeGetAttrValue(cur, BAD_CAST "tab", XML_XML_NAMESPACE,
+                                  &tab);
+        if (res < 0)
+            return(-1);
+	if (tab != NULL) {
+	    if (xmlStrEqual(tab, BAD_CAST "preserve")) {
+		xmlFree(tab);
+		return(1);
+	    }
+	    if (xmlStrEqual(tab, BAD_CAST "default")) {
+		xmlFree(tab);
+		return(0);
+	    }
+        if (xmlStrEqual(tab, BAD_CAST "expand")) {
+		xmlFree(tab);
+		return(0);
+	    }
+        if (xmlStrEqual(tab, BAD_CAST "skip")) {
+		xmlFree(tab);
+		return(0);
+	    }
+	    xmlFree(tab);
+	}
+
+	cur = cur->parent;
+    }
+
+    return(-1);
+}
+
 /**
  * xmlNodeSetName:
  * @cur:  the node being changed
